;
; Title:	C++ Runtime Initialisation Code
; Author:	Paul Cawte
; Created:	30/06/2023
; 
; Modinfo:
; Adapted from CE Toolchain crt0.src
; with parts from init.asm by Dean Belfield - which is part of the Zilog toolchain for Agon
; removed some of the optimisations from CE Toolchain for clarity
; there also appear to be bugs in the CE Toolchain version

; Labels defined in the linker_script
;   ___low_bss
;   ___len_bss
;   ___heaptop
;   ___heapbot
;   ___libs        		- commented out - not currently used (part of dynamic libs)
;   ___init_array_count		
;   ___ctors_count		
;   ___dtors_count		
;   ___fini_array_count		

; Labels defined in makefile.mk as part of the fasmg command line
;   __stack

; Symbols defined in makefile.mk
;   PROG_NAME

; In addition to calling the main function, sets up the environment
; - zero the BSS section
; - gets command line params if program has int main(int argc, char *argv[])
; - resets and globals that need to be reset if program is re-run
; - calls any C++ initialisers and constructors
; - calls the main function
;	- parameters are passed on the stack if int main(int argc, char *argv[])
;	- return value in HL
; - and return with the status in HL
;
; Later:
; - calls any C++ destructors and finalisers
; - return
; 
; storage / data structures declared and used
; - init_functions		populated by the linker from init_array and ctors
; - fini_functions		populated by the linker from dtors and fini_array
; - argv_ptrs 			storage for pointers to the command line paramters
;
; the following codes sections are used
; - section .header 		for the MOS header
; - section .libs 		not explicit - but required by linker 
; - section .init 		for the initialisation code
; - section .init.args
; - section .init.bss
; - section .fini 		for the finalistion code
; - section .text 		for the normal C code
; sections used by the linker for constructors/destructors/initialisers and finalisers
; - section .init_array
; - section .ctors
; - section .dtors
; - section .fini_array
; sections used by data
; - section .rodata 		read-only data (static)
; - section .data 		BSS

	assume	adl = 1	

argv_ptrs_max := 16			; Maximum number of arguments allowed in argv

; macro definitions
; =================

define align?

align?.INDEX = 0

macro align?.assume variable, pow2
        assert bsf(pow2) = bsr(pow2)
        repeat align?.INDEX+1
                if % = %%
                        align?.INDEX = align?.INDEX + 1
                        align?.v% = variable
                        align?.% = pow2
                else if align?.v% relativeto variable
                        align?.v% = variable
                        align?.% = pow2
                        break
                end if
        end repeat
end macro

macro align? pow2*, remainder:0, filler:?
        local offset
        offset = $
        repeat align?.INDEX
                if offset relativeto align?.v%
                        if align?.% >= pow2
                                offset = offset - align?.v%
                        else
                                err 'variable portion of address is not aligned enough'
                        end if
                end if
        end repeat
        assert bsf(pow2) = bsr(pow2)
        db (-offset+remainder)and(pow2-1) dup filler
end macro 

section .header 			; The location of this is set by locate .header in makefile.mk

__agwin_header:
	jp	__start			; Jump to start

; The header stuff required by AgWin
; --------------------------------

    public  __agwin_header
    public  __agwin_fcn_table
	extern  __agwin_app

_exec_name:
	db	PROG_NAME, ".bin", 0	; The executable name, only used in argv

	align	64  	; The executable header is from byte 64 onwards
	db	"WIN"		; Flag for AgWin - to confirm this is a valid AgWin binary
	db	00h			; AgWin header version 0
	db	01h			; Flag for run mode (0: Z80, 1: ADL)
    dl  __agwin_header ; Holds the load address of this application
    dl  __agwin_app ; Points to the AwApplication structure for this application
__agwin_fcn_table:
    dl  0           ; Points to the function table for AgWin core functions
	dl  __agwin_stop ; Points to the cleanup code for this application

; In CE Toolchain there are a few things before __start
; -----------------------------------------------------

;	section .init.libs 		; May want to add this later to Agon port
;	section .init.clock 		; TI-84-CE specific
; 	section .text

;
; Start or initialisation code and C-runtime start
; ------------------------------------------------
	section .init
	weak 	__start
__start:				; entry point - this will normally by at $040045
	PUSH	AF			; Preserve registers
	PUSH	BC
	PUSH	DE
	PUSH	IX
	PUSH	IY

	PUSH	HL			; HL is the address of the cmd line param string

; Zero the bss section
; --------------------
; The HEADER __alloc_base for malloc() is in BSS, so it should be reset as part of this

if ___len_bss > 0			
	CALL	_clear_bss 		; Clear the RAM in the BSS segment
end if

; Reset any global items necessary for rerun
; ------------------------------------------
; This includes:
; - bottom of heap used by sbrk()
; - stdin, stdout and stderr because they may have been redirected e.g. by freopen()
;   need to do this before processing command line options as they may redirect stdio

ifextern __sbrkbase
	ld 	hl, ___heapbot
	ld 	(__sbrkbase), hl
end if

ifextern __stdio_init
	call 	__stdio_init
end if

; Process command line parameters
; -------------------------------
; If calling with argc & argv get the parameters from the command line put on the stack (conditionally included)
; - this is done after clearing BSS as pointers stored in BSS

	POP	HL 				; address of command line - saved earlier on the stack

; process command line if C program is of the form int main(argc, *argv[]) 
; or the command line switch HAS_ARG_PROCESSING (as defined in the makefile) is true

ifextern ___main_argc_argv | HAS_ARG_PROCESSING
	LD 	IX, argv_ptrs			; The argv array pointer address
	PUSH	IX				; Parameter 2: *argv[0] = IX
	CALL	_parse_params			; Parse the parameters
	LD	B, 0				; Clear B from UBC as we just want ARGC
	PUSH	BC				; Parameter 1: argc
end if 		; ___main_argc_argv


; Call initialisers and constructors
; ----------------------------------

.init_count := ___init_array_count + ___ctors_count

	; Optimised version if <= 21

if .init_count <= 21
  repeat ___init_array_count				; This creates a series of inline function calls
    load function: long from init_array: (%-1) * long   ; to functs with addresses stored following the
	call	function 				; - label  init_array::  (see below) and
  end repeat
  repeat ___ctors_count
    load function: long from ctors: (%-1) * long 	; - label  ctors::   (see below)
	call	function
  end repeat

else 	; Unoptimised version - iterates over table and makes indirect calls
 	; - optimisations for number being: 1, 2 or 3 bytes

	ld	ix,init_functions			; prepare to iterate through init_functions
	ld	b,((.init_count-1) shr  0 and $FF)+1 	; [b] as counter
  if .init_count > $100
	ld	c,((.init_count-1) shr  8 and $FF)+1 	; [b:c] as counter
    if .init_count > $10000
	ld	a,((.init_count-1) shr 16 and $FF)+1    ; [a:b:c] as counter
    end if
  end if

.init_loop:
	push	bc 					; save iteration counter
  if .init_count > $10000
	push	af
  end if
	ld	hl,(ix) 				; get address of the current initialisation function
	lea	ix,ix+long 				; move point to next function ready for next iteration
	call	__indcallhl 				; call the initialisation function
  if .init_count > $10000
	pop	af 					; restore iteration counter
  end if
	pop	bc
	djnz	.init_loop 				; iterate on the count in [b]
  if .init_count > $100
	dec	c 					; iterate on the count in [c]
	jq	nz,.init_loop
    if .init_count > $10000 				
	dec	a 					; iterate on the count in [a]
	jq	nz,.init_loop
    end if
  end if
end if 		; .init_count <=21

; Call main function
; ------------------
; Start of the C program called either as int main(void) or int main(int argc, char *argv[])
; - value returned will be in HL

ifextern ___main_argc_argv
	call	___main_argc_argv		; int main(int argc, char *argv[])
else
	call	_main 				; int main(void)
end if
	public	__start._main
__start._main := $ - 3

; clear up the stack if called with argc & argv (conditionally included)
;
ifextern ___main_argc_argv 			; if int main(argc, *argv[]) clear up the stack
	POP	DE
	POP	DE
end if

	POP	IY
	POP	IX
	POP	DE
	POP BC
	POP	AF
	RET					; return to AgWin

__agwin_stop:
	PUSH	AF			; Preserve registers
	PUSH	BC
	PUSH	DE
	PUSH	IX
	PUSH	IY

;
; Calling of destructors and finalisers
; -------------------------------------

; Optimised version if <= 21

.fini_count := ___dtors_count + ___fini_array_count
if .fini_count <= 21
  repeat ___fini_array_count
    load function: long from fini_array: (%%-%) * long
	call	function
  end repeat
  repeat ___dtors_count
    load function: long from dtors: (%%-%) * long
	call	function
  end repeat

; Unoptimised version - iterates table and makes indirect calls
;
; optimisations for number being: 1, 2 or 3 bytes

else
	ld	ix,fini_functions
	ld	b,((.fini_count-1) shr  0 and $FF)+1
  if .fini_count > $100
	ld	c,((.fini_count-1) shr  8 and $FF)+1
    if .fini_count > $10000
	ld	a,((.fini_count-1) shr 16 and $FF)+1
    end if
  end if
.fini_loop:
	push	bc
  if .fini_count > $10000
	push	af
  end if
	lea	ix,ix-long
	ld	hl,(ix)
	call	__indcallhl
  if .fini_count > $10000
	pop	af
  end if
	pop	bc
	djnz	.fini_loop
  if .fini_count > $100
	dec	c
	jq	nz,.fini_loop
    if .fini_count > $10000
	dec	a
	jq	nz,.fini_loop
    end if
  end if
end if

	POP	IY
	POP	IX
	POP	DE
	POP BC
	POP	AF
	RET					; return to AgWin

	
; Clear the memory (the heap used for dynamic variables)
; ------------------------------------------------------
;
; Location of BSS is defined by the labels (coming from linker_script)
;   ___low_bss
;   ___len_bss
;
	section .init.bss
	private _clear_bss
_clear_bss:

if ___len_bss > 0 				; no need if BSS is 0 bytes
  if ___len_bss = 1 				; special case of 1 byte
	xor	a,a
	ld	(___low_bss),a
	ret

  else if ___len_bss = 2 				; special case of 2 bytes
	ld	hl,___low_bss
	xor	a,a
	ld	(hl),a
	inc	hl
	ld	(hl),a
	ret

  else if ___len_bss = 3 				; special case of 3 bytes
	or	a,a
	sbc	hl,hl
	ld	(___low_bss),hl
	ret

  else if ___len_bss < 256 			; case <256 bytes
	ld	hl,___low_bss			
	xor	a,a
	ld	b,___len_bss
.clearbssloop:
	ld 	(hl),a
	inc 	hl
	djnz 	.clearbssloop
	ret

  else if ___len_bss = 256 | ___len_bss = 257
	ld	hl,___low_bss			
	xor	a,a
	ld	b,a
.clearbssloop:
	ld	(hl),a
	inc	hl
	djnz	.clearbssloop
    if ___len_bss = 257
	ld	(hl),a
    end if
  	ret

  else 						; case >257 bytes
	ld	bc, ___len_bss-1		; first byte hence is done manually
 	ld 	hl, ___low_bss
 	ld 	de, ___low_bss+1
 	ld 	(hl), 0
 	ldir 					; copy 0 from previous location to next
 	ret
  end if
end if 	; ___len_bss > 0


; Process the command line into argc & argv[]
; -------------------------------------------
;			
; Parse the parameter string into a C array
; Parameters
; - HL: Address of parameter string (seems to be set by MOS at start of programme)
; - IX: Address for array pointer storage
; Returns:
; -  C: Number of parameters parsed
;
; Only include conditionally if ___main_argc_argv is present

	section .init.args
ifextern ___main_argc_argv | HAS_ARG_PROCESSING

	private _parse_params
_parse_params:

  if HAS_ARG_PROCESSING				; if want to do complex arg processing

  	extern 	___arg_processing

  	ld 	bc, _exec_name			; first value in argv is program name
  	ld 	(ix+0), bc
  	push	ix
  	push	hl
  	call 	___arg_processing 		; call a C function to do this
  	pop     hl
  	pop 	hl
  	ld 	bc, 0 				; clear out top of UBC
  	ld 	c, a
  	ret

  else 						; otherwise do simple arg processing

	LD	BC, _exec_name			; start of the program image 
	LD	(IX+0), BC			; store *ARGV[0] = the executable name
	INC	IX
	INC	IX
	INC	IX
	CALL	_skip_spaces			; Skip HL past any leading spaces
;
	LD	BC, 1				; C: ARGC = 1 - also clears out top 16 bits of BCU
	LD	B, argv_ptrs_max - 1		; B: Maximum number of argv_ptrs
;
_parse_params_1:	
	PUSH	BC				; Stack ARGC	
	PUSH	HL				; Stack start address of token
	CALL	_get_token			; Get the next token
	LD	A, C				; A: Length of the token in characters
	POP	DE				; Start address of token (was in HL)
	POP	BC				; ARGC
	OR	A				; Check for A=0 (no token found) OR at end of string
	RET	Z
;
	LD	(IX+0), DE			; Store the pointer to the token
	PUSH	HL				; DE=HL
	POP	DE
	CALL	_skip_spaces			; And skip HL past any spaces onto the next character
	XOR	A
	LD	(DE), A				; Zero-terminate the token
	INC	IX
	INC	IX
	INC	IX				; Advance to next pointer position
	INC	C				; Increment ARGC
	LD	A, C				; Check for C >= A
	CP	B
	JR C, 	_parse_params_1			; And loop
	RET

; Get the next token
; Parameters:
; - HL: Address of parameter string
; Returns:
; - HL: Address of first character after token
; -  C: Length of token (in characters)
;
_get_token:
	LD	C, 0				; Initialise length
get_token_loop:
	LD	A, (HL)				; Get the character from the parameter string
	OR	A				; Exit if 0 (end of parameter string in MOS)
	RET Z
	CP	13				; Exit if CR (end of parameter string in BBC BASIC)
	RET	Z
	CP	' '				; Exit if space (end of token)
	RET	Z
	INC	HL				; Advance to next character
	INC 	C				; Increment length
	JR	get_token_loop
	
; Skip spaces in the parameter string
; Parameters:
; - HL: Address of parameter string
; Returns:
; - HL: Address of next none-space character
;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
;
_skip_spaces:
	LD	A, (HL)				; Get the character from the parameter string	
	CP	' '				; Exit if not space
	RET	NZ
	INC	HL				; Advance to next character
	JR	_skip_spaces			; Increment length

  end if 	; HAS_ARG_PROCESSING
end if 		; ___main_argc_argv | HAS_ARG_PROCESSING

; Storage for the argv array pointers
;
	section .data				; need private directive to make visible in .init section

ifextern ___main_argc_argv | HAS_ARG_PROCESSING

	private argv_ptrs
argv_ptrs:
  repeat argv_ptrs_max
	dl	0			
  end repeat

end if 		; ___main_argc_argv | HAS_ARG_PROCESSING


; Storage for Initialisers, Constructors, Destructors & Finalisers 
; ----------------------------------------------------------------
; C++ has constructors (ctors) and destructors (dtors)
; with initialisation (init_functions) and finalisation(fini_functions)
; I assume some "magic" is done by the linker to fill thses tables

	section	.rodata
	private	init_functions
init_functions:				; adddress at the beginning because call from 1st to last

load functions: ___init_array_count * long from init_array: 0
	dl	functions
load functions: ___ctors_count * long from ctors: 0
	dl	functions 

	section	.rodata
	private	fini_functions
load functions: ___dtors_count * long from dtors: 0
	dl	functions
load functions: ___fini_array_count * long from fini_array: 0
	dl	functions

fini_functions: 			; address at the end because call from last to 1st


; Sections for initialisers and constructors

	section	.init_array
init_array::
	section	.ctors
ctors::

; Sections for destructors and finalisers

	section	.dtors
dtors::
	section	.fini_array
fini_array::

	extern 	_main
	extern 	___main_argc_argv

	extern 	__indcallhl
	extern 	_free
	extern 	_malloc
	extern  __sbrkbase

	extern 	___len_bss			; coming from linker_script, defined in makefile.mk
	extern 	___low_bss			; coming from linker_script, defined in makefile.mk
	extern  ___heapbot 			; coming from linker_script, defined in makefile.mk
	extern 	__stack				; defined in makefile.mk
;	extern 	___libs

	extern 	__stdio_init

	extern	___ctors_count
	extern	___dtors_count
	extern	___fini_array_count
	extern	___init_array_count

